require open Stdlib.Prop Stdlib.FOL Stdlib.Eq;
require open Stdlib.Set;
require open Stdlib.Nat;
require open Stdlib.Bool; 

// (a :Set) (b :Prop) inductive toto : TYPE â‰”
// | â–¡ : toto a b // \Box
// | â¸¬ : Ï„ a â†’ Ï€ b â†’ toto a b;

symbol ite: Prop â†’ Prop â†’ Prop â†’ Prop;
constant symbol ite_ind : Î  c t e p,
                           (Ï€ c â†’ Ï€ (p t))
                         â†’ ((Ï€ c â†’ Ï€ âŠ¥) â†’ Ï€ (p e))
                         â†’ Ï€ (p (ite c t e));

symbol âŸ‡: Prop â†’ Prop â†’ Prop;
notation âŸ‡ infix left 6;
rule $x âŸ‡ $y â†ª ($x) âˆ¨ ($y);

// Rule 3: âŠ¤ true
// Is equivalent to "top : Ï€ âŠ¤".

// Rule 13 la_disequality
constant symbol la_disequality t1 t2: Ï€ ( t1 = t2 âˆ¨ Â¬ ( istrue(t1 â‰¤ t2) ) âˆ¨ Â¬ (istrue(t1 â‰¤ t2)) );

// Rule 14 la_totality
constant symbol la_totality t1 t2: Ï€ ( istrue(t1 â‰¤ t2) âˆ¨ istrue(t2 â‰¤ t1) );

constant symbol bind p q: (Î  x, Ï€ (p x â‡” q x)) â†’ Ï€ ((âˆ€ p) â‡” (âˆ€ q));

constant symbol bind2 p q: (Î  x y , Ï€ (p x y â‡” q x y)) â†’ Ï€ ((`âˆ€ a, `âˆ€ b, p a b) â‡” (`âˆ€ x, `âˆ€ y, q x y));

//TODO: review
constant symbol sko_ex p q: (Î  x , Ï€ (p x â‡” q)) â†’ Ï€ ((`âˆƒ x, p x) â‡” q);
constant symbol sko_forall p q: (Î  x , Ï€ (p x â‡” q)) â†’ Ï€ ((`âˆ€ x, p x) â‡” q);


constant symbol notnot x : Ï€ ( (Â¬ (Â¬ (Â¬ x))) âŸ‡ x);

// Rule 22 cong version for â‡”
opaque symbol cong_â‡” x y f : Ï€ (x = y) â†’ Ï€ (f x â‡” f y) â‰”
begin
    assume x y f Hx;
    rewrite Hx;
    apply â‡”_refl;
end;

// Rule 22 cong version for =
opaque symbol cong_= [a] (x y : Ï„ a) (f: Ï„ a â†’ Ï„ a) : Ï€ (x = y) â†’ Ï€ (f x = f y) â‰”
begin
    assume x y f Hf Hx_eq_y;
    rewrite Hx_eq_y;
    reflexivity
end;

opaque symbol =_to_â‡” (x y : Ï„ bool) : Ï€ (x = y) â†’ Ï€ ((istrue x) â‡” (istrue y)) â‰”
begin
    assume x y Hx_eq_y;
    rewrite Hx_eq_y;
    apply â‡”_refl
end;

// Rule 24 eq_transitive
constant symbol eq_transitive t1 t2 t3 : Ï€ ( t1 â‡” t2 âŸ‡ t2 â‡” t3 âŸ‡ t1 â‡” t3 );

// Rule 25 eq_congruent
constant symbol eq_congruence t1 t2 u1 u2 f : Ï€ ( Â¬ (t1 â‡” u1) âŸ‡ Â¬ (t2 â‡” u2) âŸ‡ ( f t1 t2 â‡” f u1 u2));

// Rule 26 eq_congruent_pred
// where ğ‘ƒ is a function symbol with co-domain sort Bool.
//constant symbol eq_congruence_pred t1 t2 u1 u2 (p: Set â†’ Set â†’ ğ”¹) : Ï€ ( Â¬ (istrue t1 â‡”  istrue u1) âŸ‡ Â¬ (istrue t2 â‡”  istrue u2) âŸ‡ (istrue(p t1 t2) â‡” istrue(p u1 u2)));


//Rule 28: and i
// Similar to and âˆ§â‚‘ but for i elements

constant symbol equiv_pos1 Ï†â‚ Ï†â‚‚ : Ï€ (Â¬ (Ï†â‚ â‡” Â¬ Ï†â‚‚) âŸ‡ Ï†â‚ âŸ‡ Â¬ Ï†â‚‚);

constant symbol equiv_pos2 Ï†â‚ Ï†â‚‚ : Ï€ (Â¬ (Ï†â‚ â‡” Â¬ Ï†â‚‚) âŸ‡ Â¬ Ï†â‚ âŸ‡ Ï†â‚‚);

opaque symbol or_simplifyâ‚ x : Ï€ ( x âˆ¨ âŠ¥ ) â†’ Ï€ ( x ) â‰”
begin
    assume x HorX;
    apply âˆ¨â‚‘ HorX 
    { assume Hx; apply Hx; }
    { assume HFalse; apply âŠ¥â‚‘ HFalse }
end;

// Rule 56 equiv_neg1
constant symbol equiv_neg1 Ï†â‚ Ï†â‚‚ : Ï€ ((Ï†â‚ â‡” Ï†â‚‚) âŸ‡ Â¬ Ï†â‚ âŸ‡ Â¬ Ï†â‚‚);

// Rule 57
constant symbol equiv_neg2 Ï†â‚ Ï†â‚‚ : Ï€ ((Ï†â‚ â‡” Ï†â‚‚) âŸ‡ Ï†â‚ âŸ‡ Ï†â‚‚);

// FIXME: ite1 order of Ï†â‚, Ï†â‚ƒ should be inverse
// Rule 58
constant symbol ite1 Ï†â‚ Ï†â‚‚ Ï†â‚ƒ: Ï€ (ite Ï†â‚ Ï†â‚‚ Ï†â‚ƒ) â†’ Ï€ (Ï†â‚ âŸ‡ Ï†â‚‚);

// Rule 59
constant symbol ite2 Ï†â‚ Ï†â‚‚ Ï†â‚ƒ: Ï€ (ite Ï†â‚ Ï†â‚‚ Ï†â‚ƒ) â†’ Ï€ (Â¬ Ï†â‚ âŸ‡ Ï†â‚ƒ);

// Rule 60
constant symbol ite_pos1 Ï†â‚ Ï†â‚‚ Ï†â‚ƒ: Ï€ (Â¬ (ite Ï†â‚ Ï†â‚‚ Ï†â‚ƒ) âŸ‡ Â¬ Ï†â‚ âŸ‡ Ï†â‚ƒ);

// Rule 61
constant symbol ite_pos2 Ï†â‚ Ï†â‚‚ Ï†â‚ƒ: Ï€ (Â¬ (ite Ï†â‚ Ï†â‚‚ Ï†â‚ƒ) âŸ‡ Â¬ Ï†â‚ âŸ‡ Ï†â‚‚);

// Rule 62
constant symbol ite_neg1 Ï†â‚ Ï†â‚‚ Ï†â‚ƒ: Ï€ (ite Ï†â‚ Ï†â‚‚ Ï†â‚ƒ âŸ‡ Â¬ Ï†â‚ âŸ‡ Ï†â‚ƒ);

// Rule 63
constant symbol ite_neg2 Ï†â‚ Ï†â‚‚ Ï†â‚ƒ: Ï€ (ite Ï†â‚ Ï†â‚‚ Ï†â‚ƒ âŸ‡ Â¬ Ï†â‚ âŸ‡ Â¬ Ï†â‚‚);

// Rule 64
constant symbol not_ite1 Ï†â‚ Ï†â‚‚ Ï†â‚ƒ: Ï€ (Â¬ (ite Ï†â‚ Ï†â‚‚ Ï†â‚ƒ)) â†’ Ï€ ( Ï†â‚ âŸ‡ Â¬ Ï†â‚ƒ);

// Rule 65
constant symbol not_ite2 Ï†â‚ Ï†â‚‚ Ï†â‚ƒ: Ï€ (Â¬ (ite Ï†â‚ Ï†â‚‚ Ï†â‚ƒ)) â†’ Ï€ ( Â¬ Ï†â‚ âŸ‡ Â¬ Ï†â‚‚);

// Rule cannot be given on defined symbol
// QUESTION: Should we unroll the definition and do the rewrite rule on it ?
//rule Â¬ (Â¬ $x) â†ª $x;

// rule 72 bool_simplify
//rule ($x â‡’ $y) â‡’ âŠ¥ â†ª ($x âˆ§ Â¬ $y);


// QUESTION: ask if we can remove the `constant` for disjunction, or
// we can not implement or_simplify with rewriting rules.
// Rule 68:  or_simplify
//  âŠ¥ âˆ¨ â‹¯ âˆ¨ âŠ¥ â‡’ âŠ¥
// rule âŠ¥ âˆ¨ âŠ¥ â†ª âŠ¥;

// compute âŠ¥ âˆ¨ âŠ¥ âˆ¨ âŠ¥ âˆ¨ âŠ¥;


// // ğœ‘1 âˆ¨ â‹¯ âˆ¨ ğœ‘ğ‘› â‡’ ğœ‘1 âˆ¨ â‹¯ âˆ¨ ğœ‘ğ‘›â€² where the right-hand side has all âŠ¥ literals removed.
// rule $x âˆ¨ âŠ¥ â†ª $x;

// compute  âŠ¤ âˆ¨ âŠ¥ âˆ¨ âŠ¥ âˆ¨ âŠ¥ âˆ¨ âŠ¥;

// // ğœ‘1 âˆ¨ â‹¯ âˆ¨ ğœ‘ğ‘› â‡’ ğœ‘1 âˆ¨ â‹¯ âˆ¨ ğœ‘ğ‘›â€² where the right-hand side has all repeated literals removed.
// rule $x âˆ¨ $x â†ª $x;
// rule $x âˆ¨ $y âˆ¨ $x â†ª $x âˆ¨ $y;
// rule $x âˆ¨ $y âˆ¨ $z âˆ¨ $x â†ª $x âˆ¨ $y âˆ¨ $z;

// // ğœ‘1 âˆ¨ â‹¯ âˆ¨ âŠ¤ âˆ¨ â‹¯ âˆ¨ ğœ‘ğ‘› â‡’ âŠ¤
// rule $x âˆ¨ âŠ¤ â†ª âŠ¤;

// compute  âŠ¥ âˆ¨ âŠ¥ âˆ¨ âŠ¥ âˆ¨ âŠ¥ âˆ¨ âŠ¤ ;

// Rule 69: not_simplify


// Rul 74: ite_simplify 
rule ite âŠ¤ $t1 $t2 â†ª $t1
with ite âŠ¥ $t1 $t2 â†ª $t2
with ite $c $t $t â†ª $t
with ite (Â¬ $c) $t1 $t2  â†ª ite $c $t2 $t1
with ite $c (ite $c $t1 $t2) $t3 â†ª ite $c $t1 $t3
with ite $c $t1 (ite $c $t2 $t3) â†ª ite $c $t1 $t3
with ite $c âŠ¤ âŠ¥ â†ª $c
with ite $c âŠ¥ âŠ¤  â†ª Â¬ $c
with ite $x âŠ¤ $y â†ª $x âˆ¨ $y
with ite $x $y âŠ¥ â†ª $x âˆ§ $y
with ite $x âŠ¥ $y â†ª (Â¬ $x) âˆ§ $y
with ite $x $y âŠ¤  â†ª (Â¬ $x) âˆ¨ $y;



opaque symbol resolutionâ‚— x a b: Ï€ (x âˆ¨ a) â†’ Ï€ ((Â¬ x) âˆ¨ b) â†’ Ï€ (a âˆ¨ b) â‰”
begin
    assume x a b ClauseXA ClauseNotXB;
    apply âˆ¨â‚‘ ClauseXA
    {
        assume Hx;
        apply âˆ¨â‚‘ ClauseNotXB
        { assume Hnotx; apply Â¬â‚‘ Hnotx Hx }
        { assume Hb; apply âˆ¨áµ¢â‚‚ Hb }
    }
    { assume Ha; apply âˆ¨áµ¢â‚ Ha };
end;

opaque symbol resolutionáµ£ x a b: Ï€ (a âˆ¨ x) â†’ Ï€ (b âˆ¨ (Â¬ x)) â†’ Ï€ (a âˆ¨ b) â‰”
begin
    assume x a b ClauseAX ClauseBNotX;
    apply resolutionâ‚— x a b (âˆ¨_com ClauseAX) (âˆ¨_com ClauseBNotX)
end;
